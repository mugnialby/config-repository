# APPLICATION CONFIG
spring:
  cloud:
    gateway:
      routes:
        - id: "auth_service_route"
          uri: "http://localhost:7002"
          predicates:
            - Path=/api/v1/auth/**
          filters:
            - name: "CircuitBreaker"
              args:
                name: "authCircuitBreaker"
                fallbackuri: forward:/api/v1/fallback/
        - id: "user_service_route"
          uri: "http://localhost:7003"
          predicates:
            - Path=/api/v1/users/**
          filters:
            - name: "CircuitBreaker"
              args:
                name: "userCircuitBreaker"
                fallbackuri: forward:/api/v1/fallback/
            - AuthorizationFilter
logging:
  level:
    root: "INFO"
  file:
    name: "logs/${spring.application.name}-${today:dd-MM-yyyy}-logs.log"
  appenders:
    file:
      type: "ch.qos.logback.core.rolling.RollingFileAppender"
      file: "logs/${spring.application.name}-${today:dd-MM-yyyy}-logs.log"
      rollingPolicy:
        type: "ch.qos.logback.core.rolling.TimeBasedRollingPolicy"
        fileNamePattern: "logs/${spring.application.name}-${today:dd-MM-yyyy}-%i.log"
        maxFileSize: "10MB"
        totalSizeCap: "10GB"
        maxHistory: 30
      encoder:
        type: "ch.qos.logback.classic.encoder.PatternLayoutEncoder"
        pattern: {
          "timestamp": "%d{yyyy-MM-dd'T'HH:mm:ss.SSSXXX}",
          "level": "%level",
          "thread": "%thread",
          "logger": "%logger{36}",
          "message": "%msg"
        }
server:
  port: 7000
  error:
    include-message: "always"

resilience4j:
  retry:
    instances:
      myRetry:
        max-attempts: 3
        wait-duration: 5s

rabbitmq:
  queue:
    authorization:
      request: "authorization.request.queue"
      response: "authorization.response.queue"
  exchange:
    authorization: "authorization.exchange"
